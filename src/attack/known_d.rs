use indicatif::ProgressBar;
use rug::{ops::Pow, rand::RandState, Integer};

use crate::{
    key::PrivateKey, utils::log_base_ceil, Attack, AttackSpeed, Error, Parameters, Solution,
};

/// Known phi attack
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct KnownDAttack;

impl Attack for KnownDAttack {
    fn name(&self) -> &'static str {
        "known_d"
    }

    fn speed(&self) -> AttackSpeed {
        AttackSpeed::Fast
    }

    fn run(&self, params: &Parameters, _pb: Option<&ProgressBar>) -> Result<Solution, Error> {
        let e = &params.e;
        let n = params.n.as_ref().ok_or(Error::MissingParameters)?;
        let d = params.d.as_ref().ok_or(Error::MissingParameters)?;

        let k = e * d - Integer::from(1);
        let bits = log_base_ceil(&k, 2);

        let mut rgen = RandState::new();
        loop {
            let g = (n.clone() - Integer::from(1)).random_below(&mut rgen) + Integer::from(1);
            for s in 1..=bits as u32 {
                let x = Integer::from(g.pow_mod_ref(&(&k / Integer::from(2).pow(s)), n).unwrap());
                let p = Integer::from(n.gcd_ref(&(x - Integer::from(1))));
                if p > 1 && p < *n && n.is_divisible(&p) {
                    let q = Integer::from(n / &p);
                    return Ok(Solution::new_pk(
                        self.name(),
                        PrivateKey::from_p_q(p, q, e.clone())?,
                    ));
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use crate::{Attack, Parameters};

    use super::*;

    #[test]
    fn two_factors() {
        let params = Parameters {
            n: Some(Integer::from_str("595644324678330029064750136453542164009779182181884516126664093694657966395508462357386906209978220102994182148722067637395631038425868144218230512943422416048584820258481784811989688053517984006270893341616503299324058258213767861788823799128254099984032505506431285822537868474696687149451794143404761870870780697040422403376219269294607269599100398420518216948522034204435868198929148137405452459506624733053720993141194037281144253184411903537574109886246871444466696667896439571609587881603453027884269561129139745160489509339344723376266485135403839093394327257113134059714467260522027365574777").unwrap()),
            d: Some(Integer::from_str("305352127442785815439956213046518090303745230690522515347170812760111443871246743211027784120979572772636763014032001867854509910401664587047009941611000853136156739036333865210925394045104959162895512513515871360413054996432670992760106705819795733664396296557663181253029659080281132767141186319726515894424706179996493920987917760397380599013789514964087569930331219929889707497431750219656767422074394908006578036272443782014579159208917685835255356253925360525430889844833417847812902573829385331316062247131559133063461364497204724380000432453598366487932070818104429582983708584782702418015189").unwrap()),
            ..Default::default()
        };

        let solution = KnownDAttack.run(&params, None).unwrap();
        let pk = solution.pk.unwrap();

        assert_eq!(pk.p, Integer::from_str("619725990001524703456465713279465625846752832414168572011466066232082436863841189586501588353354943054775532335900016320501197905886582011529076059068049302722289071314361386097002051734252322740808308805710458547662135247973085180484778717957169307399128511564888941495042113300382369335995877815563").unwrap());
        assert_eq!(pk.q, Integer::from_str("961141430710150744852888885216606265327700813871292735032123072541546834239236573911369525935582156732540361058711390750890531374856612832113164217347913046140103022163728329963032320241017138138876928547833993486588456012463816930437584873444942767568476855020374256145222297933467290778138867303179").unwrap());
    }
}
